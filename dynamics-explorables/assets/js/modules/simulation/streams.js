export {Stream};

/**
 * Generate data for your visualization in real time and visualize it.
 *
 * The core idea of this class is to simulate data at a slower rate but in
 * bigger chunks than the visualization. This allows to have a precomputed
 * buffer of data which the simulation can this use.
 *
 * Some terminology:
 *  - A "chunk" is the amount of data that is simulated in one step. Chunks are
 * generated by the callback function `generateChunk() -> chunk`.
 * Roughly speaking, a chunk is the amount of data that it would take 1-10
 * seconds to visualize. They should not be too small so that the visualization
 * always has sufficient buffer, but also not too large to impact performance.
 * - A "crumb" is a tiny piece of data that is visualized in one frame. So, for
 * example, if you set `fps = 30`, 30 crumbs will be visualized per second by
 * calling the function `drawCrumb(crumb) -> void`.
 * - A chunk is transformed into an array of crumbs by the callback
 * `crumbleChunk(chunk) -> [array of crumbs]`.
 *
 * See lorenz-attractor.js for an example of how to use streams.
 *
 * Right now, any arguments to the callbacks, in particular `generateChunks`,
 * are not supported; use global variables to pass the state of the simulation.
 * This is super not pretty, I'll think how we can handle it better.
 */
class Stream {
  constructor(
      generateChunk, crumbleChunk, drawCrumb, fps, animationPlaying = true) {
    this.animationPlaying = animationPlaying;
    this.fps = fps;

    this.simulationStream = new ReadableStream({
      async pull(controller) {
        let chunk = generateChunk();
        controller.enqueue(chunk);
      },
      cancel() {},
    });

    this.splitChunksStream = new TransformStream(
        {
          async transform(chunk, controller) {
            let crumbs = crumbleChunk(chunk);
            for (const crumb of crumbs) {
              controller.enqueue(crumb);
            }
          },
        },
        {highWaterMark: 2}, {highWaterMark: 100});

    this.animationStream = new WritableStream({
      async write(crumb) {
        drawCrumb(crumb);
      },
      close() {},
      abort(err) {
        console.log('Animation stream aborted');
      }
    });

    const pipeline = this.simulationStream.pipeThrough(this.splitChunksStream);
    this.animationReader = pipeline.getReader();
    this.animationWriter = this.animationStream.getWriter();

    this.timeoutID = undefined;
    if (animationPlaying) {
      this.play();
    }
  }

  async drawFrame() {
    await this.animationReader.read().then(({done, value}) => {
      this.animationWriter.write(value);
    });
    this.timeoutID = setTimeout(this.drawFrame.bind(this), 1000 / this.fps);
  }

  play() {
    this.animationPlaying = true;
    this.timeoutID = setTimeout(this.drawFrame.bind(this), 1000 / this.fps);
  }

  pause() {
    this.animationPlaying = false;
    clearInterval(this.timeoutID);
  }

  togglePausePlay() {
    if (this.animationPlaying) {
      this.pause();
    } else {
      this.play();
    }
  }

  abort() {
    clearInterval(this.timeoutID);
    this.animationWriter.abort();
  }
}